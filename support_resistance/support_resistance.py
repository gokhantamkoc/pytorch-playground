from flask import Flask, request

from sklearn.preprocessing import MinMaxScaler
from zigzag import peak_valley_pivots
from itertools import combinations
import mplfinance
import datetime
import pandas
import numpy
import sys


class SupportResistanceLines:
    def __init__(self):
        pass

    def create_chart(self, dataframe: pandas.DataFrame):
        """Visualize the lines and the peak/valley points generated by the algorithm"""

        def get_points(label):
            indices = dataframe.loc[dataframe["pivots"] == label].index
            points = pandas.DataFrame([float("nan")] * len(dataframe))

            points.iloc[indices, 0] = dataframe.loc[indices, "close"]

            return points

        peak_points = get_points(label=1)
        valley_points = get_points(label=-1)

        aps = [
            mplfinance.make_addplot(dataframe[["support", "resistance"]]),
            mplfinance.make_addplot(peak_points, type="scatter", markersize=7, marker="o", color="#00FF00"),
            mplfinance.make_addplot(valley_points, type="scatter", markersize=7, marker="o", color="#FF0000"),
        ]

        dataframe["timestamp"] = dataframe["timestamp"].apply(lambda x: datetime.datetime.fromtimestamp(float(x) / 1e3))
        dataframe = dataframe.set_index("timestamp")
        mplfinance.plot(
            dataframe[["open", "high", "low", "close"]],
            type="candle",
            style="yahoo",
            addplot=aps,
            warn_too_much_data=len(dataframe) + 1,
            savefig="support_resistance_line_chart.png",    #PNG_save_file_path
        )

    def get_pivot_points(self, dataframe: pandas.DataFrame, turning_point_sens: float):
        """Mark local maximums and local minimums"""

        pivots = peak_valley_pivots(dataframe["close"].values, turning_point_sens, (turning_point_sens * -1))
        pivots[0] = 0
        pivots[-1] = 0

        return pivots

    def get_combinations(self, dataframe: pandas.DataFrame):
        """Generate all possible combinations of the local maximums and minimums without repetition"""

        resistance_timestamps = dataframe.loc[dataframe["pivots"] == 1]["timestamp"]
        support_timestamps = dataframe.loc[dataframe["pivots"] == -1]["timestamp"]

        resistance_combinations = list(combinations(resistance_timestamps, 2))
        support_combinations = list(combinations(support_timestamps, 2))

        return resistance_combinations, support_combinations

    def extend_line(
        self,
        dataframe: pandas.DataFrame,
        far_index: numpy.int64,
        near_index: numpy.int64,
    ):
        """Extend the line to the end of the dataframe"""

        last_point = round(
            ((dataframe["close"][near_index] - dataframe["close"][far_index]) / (near_index - far_index))
            * (len(dataframe) - far_index)
            + dataframe["close"][far_index],
            2,
        )
        line = numpy.linspace(dataframe["close"][far_index], last_point, (len(dataframe) - far_index + 1)).round(2)[:-1]

        return line

    def get_fitness_metrics(
        self, dataframe: pandas.DataFrame, combinations: list, line_type: str, break_threshold: float
    ):
        """Calculate fitnness metrocs"""

        fitness_metrics = pandas.DataFrame(combinations, columns=["timestamp_1", "timestamp_2"])
        fitness_metrics[
            [
                "length",
                "slope_diff",
                "near_distance",
                "num_hits",
                "relevancy",
                "drop",
            ]
        ] = 0

        for row in fitness_metrics.itertuples():
            far_index = dataframe.loc[dataframe["timestamp"] == row.timestamp_1].index[0]
            near_index = dataframe.loc[dataframe["timestamp"] == row.timestamp_2].index[0]

            dataframe.loc[far_index:, "line"] = self.extend_line(
                dataframe=dataframe, far_index=far_index, near_index=near_index
            )

            if line_type == "resistance":
                if (
                    len(
                        dataframe.loc[
                            (dataframe["pivots"] == 1) & (dataframe["line"] / dataframe["close"] < break_threshold)
                        ]
                    )
                    > 0
                ):
                    fitness_metrics.at[row.Index, "drop"] = 1
                    continue

                fitness_metrics.at[row.Index, "relevancy"] = abs(
                    dataframe.iloc[-1]["line"] - dataframe.iloc[-1]["close"]
                )
                fitness_metrics.at[row.Index, "num_hits"] = len(
                    dataframe.loc[
                        (dataframe["pivots"] == 1)
                        & ((dataframe["line"] < dataframe["high"]) & (dataframe["line"] > dataframe["low"]))
                    ]
                )
            else:
                if (
                    len(
                        dataframe.loc[
                            (dataframe["pivots"] == -1) & (dataframe["close"] / dataframe["line"] < break_threshold)
                        ]
                    )
                    > 0
                ):
                    fitness_metrics.at[row.Index, "drop"] = 1
                    continue

                fitness_metrics.at[row.Index, "relevancy"] = abs(
                    dataframe.iloc[-1]["close"] - dataframe.iloc[-1]["line"]
                )
                fitness_metrics.at[row.Index, "num_hits"] = len(
                    dataframe.loc[
                        (dataframe["pivots"] == -1)
                        & ((dataframe["line"] < dataframe["high"]) & (dataframe["line"] > dataframe["low"]))
                    ]
                )

            fitness_metrics.at[row.Index, "length"] = near_index - far_index
            fitness_metrics.at[row.Index, "slope_diff"] = abs(
                numpy.polyfit(
                    numpy.array(range(0, len(dataframe[far_index:]))),
                    dataframe[far_index:]["close"].to_numpy(),
                    1,
                )[0]
                - ((dataframe["close"][near_index] - dataframe["close"][far_index]) / (near_index - far_index))
            )
            fitness_metrics.at[row.Index, "near_distance"] = len(dataframe) - near_index

            dataframe.drop(["line"], axis=1, inplace=True)

        fitness_metrics.drop(
            fitness_metrics.loc[fitness_metrics["drop"] == 1].index,
            axis=0,
            inplace=True,
        )
        fitness_metrics.drop(["drop"], axis=1, inplace=True)
        fitness_metrics.reset_index(drop=True, inplace=True)
        return fitness_metrics

    def normalize_metrics(self, fitness_metrics: pandas.DataFrame):
        """Normalize the metrics by using min-max scaler"""

        fitness_metrics[
            [
                "length",
                "num_hits",
                "near_distance",
                "slope_diff",
                "relevancy",
            ]
        ] = MinMaxScaler().fit_transform(
            fitness_metrics[
                [
                    "length",
                    "num_hits",
                    "near_distance",
                    "slope_diff",
                    "relevancy",
                ]
            ]
        )
        return fitness_metrics

    def get_fitness_score(self, fitness_metrics: pandas.DataFrame):
        """Calculate the fitness score based on the formula"""

        scores = (
            ((+fitness_metrics["length"] - fitness_metrics["near_distance"]) / 2)
            + fitness_metrics["num_hits"]
            - fitness_metrics["slope_diff"]
            - fitness_metrics["relevancy"]
        )
        return scores

    def generate_support_resistance_line(
        self,
        dataframe: pandas.DataFrame,
        turning_point_sens: float,
        break_threshold: float,
        draw_chart: bool,
    ):
        """Dataframe.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']"""
        dataframe["pivots"] = self.get_pivot_points(dataframe=dataframe, turning_point_sens=turning_point_sens)

        resistance_combinations, support_combinations = self.get_combinations(dataframe=dataframe)

        resistance_fitness_metrics = self.get_fitness_metrics(
            dataframe=dataframe,
            combinations=resistance_combinations,
            line_type="resistance",
            break_threshold=break_threshold,
        )
        support_fitness_metrics = self.get_fitness_metrics(
            dataframe=dataframe, 
            combinations=support_combinations, 
            line_type="support", 
            break_threshold=break_threshold
        )

        resistance_fitness_metrics = self.normalize_metrics(fitness_metrics=resistance_fitness_metrics)
        support_fitness_metrics = self.normalize_metrics(fitness_metrics=support_fitness_metrics)

        resistance_fitness_metrics["score"] = self.get_fitness_score(fitness_metrics=resistance_fitness_metrics)
        support_fitness_metrics["score"] = self.get_fitness_score(fitness_metrics=support_fitness_metrics)

        best_resistance_timestamps = (
            resistance_fitness_metrics["timestamp_1"][resistance_fitness_metrics["score"].idxmax()],
            resistance_fitness_metrics["timestamp_2"][resistance_fitness_metrics["score"].idxmax()],
        )
        best_support_timestamps = (
            support_fitness_metrics["timestamp_1"][support_fitness_metrics["score"].idxmax()],
            support_fitness_metrics["timestamp_2"][support_fitness_metrics["score"].idxmax()],
        )

        resistance_far_index = dataframe.loc[dataframe["timestamp"] == best_resistance_timestamps[0]].index[0]
        resistance_near_index = dataframe.loc[dataframe["timestamp"] == best_resistance_timestamps[1]].index[0]
        support_far_index = dataframe.loc[dataframe["timestamp"] == best_support_timestamps[0]].index[0]
        support_near_index = dataframe.loc[dataframe["timestamp"] == best_support_timestamps[1]].index[0]

        dataframe.loc[resistance_far_index:, "resistance"] = self.extend_line(
            dataframe, resistance_far_index, resistance_near_index
        )
        dataframe.loc[support_far_index:, "support"] = self.extend_line(
            dataframe, support_far_index, support_near_index
        )

        if draw_chart == True:
            self.create_chart(dataframe=dataframe)

        return dataframe

    def generate_support_resistance_lines(self):
        """Generate the trend lines for every candle in the given time interval in order to generate data for model training"""

        dataframe = self.candle_service.get_candle(
            self.config_service.sr_start_timestamp,
            self.config_service.sr_end_timestamp,
            self.config_service.sr_exchange,
            self.config_service.sr_kline_symbol,
            self.config_service.sr_time_interval,
        )

        dataframe["resistance"] = float("nan")
        dataframe["support"] = float("nan")

        for i in range(self.config_service.sr_window_size, (len(dataframe) + 1)):
            try:
                df = dataframe[(i - self.config_service.sr_window_size) : i].copy()
                df.reset_index(drop=True, inplace=True)

                df = self.generate_support_resistance_line(
                    dataframe=dataframe,
                    turning_point_sens=self.config_service.sr_turning_point_sensitivity,
                    break_threshold=self.config_service.sr_break_threshold,
                    draw_chart=False,
                )
            except KeyboardInterrupt:
                sys.exit()
            except:
                print(f"Error at: {i-1}/{len(dataframe)} | timestamp: {dataframe['timestamp'][i]}")
                dataframe.loc[i - 1, "resistance"] = dataframe["resistance"][i - 2] + (
                    dataframe["resistance"][i - 2] - dataframe["resistance"][i - 3]
                )
                dataframe.loc[i - 1, "support"] = dataframe["support"][i - 2] + (
                    dataframe["support"][i - 2] - dataframe["support"][i - 3]
                )
            else:
                print(f"{i-1}/{len(dataframe)}")
                dataframe.loc[i - 1, "resistance"] = df.iloc[-1]["resistance"]
                dataframe.loc[i - 1, "support"] = df.iloc[-1]["support"]

        dataframe.dropna(inplace=True)
        dataframe.reset_index(drop=True, inplace=True)
        dataframe.to_csv(self.config_service.sr_csv_write_path, index=False)


app = Flask(__name__)
sr = SupportResistanceLines()


@app.route("/lines", methods=["GET"])
def get_lines():
    args = request.args

    dataframe = # get_candle(args["start_timestamp"], args["end_timestamp"], args["exchange"], args["pair"], args["time_frame"]) 

    data = sr.generate_support_resistance_line(
        dataframe=dataframe, turning_point_sens=float(args["tps"]), break_threshold=float(args["bth"]), draw_chart=True
    )

    return data[["timestamp", "resistance", "support"]].to_json(orient="records")


if __name__ == "__main__":
    app.run()
